import os
from flask import Flask, request, redirect, url_for, render_template, send_from_directory, flash
from werkzeug.utils import secure_filename
import subprocess # To call your po_processor.py script
import uuid # To create unique filenames

# --- Configuration ---
# It's good practice to put these in environment variables or a config file for production
# For simplicity here, we define them directly.
UPLOAD_FOLDER = 'uploads'
OUTPUT_FOLDER = 'outputs'
ALLOWED_EXTENSIONS = {'xlsx'}

app = Flask(__name__)
app.config['UPLOAD_FOLDER'] = UPLOAD_FOLDER
app.config['OUTPUT_FOLDER'] = OUTPUT_FOLDER
app.config['MAX_CONTENT_LENGTH'] = 16 * 1024 * 1024  # 16 MB limit
app.secret_key = 'super secret key' # Change this in production!

# --- Helper Functions ---
def allowed_file(filename):
    return '.' in filename and \
           filename.rsplit('.', 1)[1].lower() in ALLOWED_EXTENSIONS

def ensure_dir(directory):
    if not os.path.exists(directory):
        os.makedirs(directory)

# --- Routes ---
@app.route('/', methods=['GET', 'POST'])
def upload_file():
    ensure_dir(app.config['UPLOAD_FOLDER'])
    ensure_dir(app.config['OUTPUT_FOLDER'])
    # Declare temp_config_path here to ensure it's always defined for finally block
    temp_config_path = None 
    input_filepath = None

    if request.method == 'POST':
        if 'file' not in request.files:
            flash('No file part')
            return redirect(request.url)
        file = request.files['file']
        if file.filename == '':
            flash('No selected file')
            return redirect(request.url)
        if file and allowed_file(file.filename):
            original_filename = secure_filename(file.filename)
            unique_id = str(uuid.uuid4())
            input_filename = f"{unique_id}_{original_filename}"
            output_filename = f"{unique_id}_Output_Stock_Management.xlsx"

            input_filepath = os.path.join(app.config['UPLOAD_FOLDER'], input_filename)
            output_filepath = os.path.join(app.config['OUTPUT_FOLDER'], output_filename)

            file.save(input_filepath)
            # Flash message moved to after potential processing error for better UX

            try:
                import config as original_config_module

                # Helper to escape strings for inclusion in the generated Python config string
                def escape_config_string(value):
                    return value.replace('\\', '\\\\').replace("'", "\\'").replace('\n', '\\n')

                temp_config_content = (
                    f"# Temporary configuration generated by app.py\n"
                    f"INPUT_EXCEL_FILE = r'''{input_filepath}'''\n"
                    f"OUTPUT_EXCEL_FILE = r'''{output_filepath}'''\n"
                    f"\n"
                    f"# Carry over other essential configurations from the original config.py's defaults\n"
                    f"TODAY_DATE_STR = '''{escape_config_string(original_config_module.TODAY_DATE_STR_DEFAULT)}'''\n"
                    f"LEAD_TIME_DAYS = {original_config_module.LEAD_TIME_DAYS_DEFAULT}\n"
                    f"FAR_FUTURE_DATE_STR = '''{escape_config_string(original_config_module.FAR_FUTURE_DATE_STR_DEFAULT)}'''\n"
                    f"CAPACITY_TOLERANCE = {original_config_module.CAPACITY_TOLERANCE_DEFAULT}\n"
                    f"MIN_CAPACITY_REMAIN = {original_config_module.MIN_CAPACITY_REMAIN_DEFAULT}\n"
                    f"OCD_COL_NAME = '''{escape_config_string(original_config_module.OCD_COL_NAME_DEFAULT)}'''\n"
                    f"FAR_FUTURE_DATE_DISPLAY_STR = '''{escape_config_string(original_config_module.FAR_FUTURE_DATE_DISPLAY_STR_DEFAULT)}'''\n"
                )
                
                temp_config_filename = f"{unique_id}_config.py"
                temp_config_path = os.path.join(app.config['UPLOAD_FOLDER'], temp_config_filename)

                with open(temp_config_path, "w") as f_temp_config:
                    f_temp_config.write(temp_config_content)

                python_executable = "python3"
                script_path = "po_processor.py"
                project_root = os.path.dirname(os.path.abspath(__file__))

                process = subprocess.run(
                    [python_executable, script_path],
                    env=dict(os.environ, PO_PROCESSOR_CONFIG=temp_config_path),
                    capture_output=True, text=True, check=False,
                    cwd=project_root
                )

                if process.returncode == 0 and os.path.exists(output_filepath):
                    flash(f'File "{original_filename}" processed successfully!')
                    return redirect(url_for('download_file', filename=output_filename))
                else:
                    # Construct a more detailed error message
                    error_detail = f"Return code: {process.returncode}."
                    if process.stderr:
                        error_detail += f" Stderr: {process.stderr.strip()}"
                    if process.stdout:
                        error_detail += f" Stdout: {process.stdout.strip()}"
                    if not os.path.exists(output_filepath) and process.returncode == 0:
                         error_detail += " Output file was not found even after script reported success."
                    flash(f'Error processing file "{original_filename}". {error_detail}')
                    return redirect(request.url)

            except Exception as e:
                flash(f'An unexpected error occurred: {str(e)}')
                return redirect(request.url)
            finally:
                # Clean up temporary files in all cases (success, error, exception)
                if temp_config_path and os.path.exists(temp_config_path):
                    os.remove(temp_config_path)
                # Optionally, remove input_filepath on failure or always after processing
                # For now, keeping it for easier debugging if an error occurs
                # if input_filepath and os.path.exists(input_filepath):
                #     os.remove(input_filepath)
        else:
            flash('Allowed file types are .xlsx')
            return redirect(request.url)

    return render_template('index.html')

@app.route('/outputs/<filename>')
def download_file(filename):
    return send_from_directory(app.config['OUTPUT_FOLDER'], filename, as_attachment=True)

if __name__ == '__main__':
    # For local development:
    app.run(debug=True)
    # For deployment on services like PythonAnywhere, you usually don't include app.run()
    # The WSGI server (like Gunicorn) will run the app. 