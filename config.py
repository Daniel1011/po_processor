import os
import pandas as pd
import datetime
from datetime import date # For date.today()

# --- Dynamic Configuration Loading ---
# This section allows app.py to override configuration values
# by providing a path to a temporary configuration file via an environment variable.

_ENV_CONFIG_PATH = os.getenv('PO_PROCESSOR_CONFIG')

# Default values (these will be used if not overridden by the temp config)
INPUT_EXCEL_FILE_DEFAULT = 'PO - Request.xlsx'
OUTPUT_EXCEL_FILE_DEFAULT = 'Output_Stock_Management.xlsx'
TODAY_DATE_STR_DEFAULT = date.today().strftime('%Y-%m-%d') # Default to today
LEAD_TIME_DAYS_DEFAULT = 40
FAR_FUTURE_DATE_STR_DEFAULT = '2200-12-31'
CAPACITY_TOLERANCE_DEFAULT = 2000
MIN_CAPACITY_REMAIN_DEFAULT = -2000
OCD_COL_NAME_DEFAULT = "OCD( Order Creation Day)"
FAR_FUTURE_DATE_DISPLAY_STR_DEFAULT = 'Insufficient Stock/Capacity'

if _ENV_CONFIG_PATH and os.path.exists(_ENV_CONFIG_PATH):
    # If the environment variable is set and the temp config file exists,
    # execute it. This will load variables like INPUT_EXCEL_FILE, OUTPUT_EXCEL_FILE,
    # TODAY_DATE_STR etc., from the temp config into the current global scope.
    _globals = globals()
    with open(_ENV_CONFIG_PATH, 'r') as f:
        exec(f.read(), _globals)

    # Ensure all expected variables are present after exec, falling back to defaults if necessary
    # The temp config generated by app.py should define these directly.
    # For example, app.py writes: INPUT_EXCEL_FILE = '/path/to/uploads/uuid_PO - Request.xlsx'
    # So, after exec, INPUT_EXCEL_FILE in this scope will hold that path.
    
    # The temp config from app.py should define these directly, so direct assignment after exec is good.
    # For any variable that app.py might *not* put in the temp config,
    # you might need to assign defaults carefully.
    # However, app.py's current temp config logic aims to set INPUT_EXCEL_FILE and OUTPUT_EXCEL_FILE.
    # It also preserves original TODAY_DATE_STR, LEAD_TIME_DAYS etc. from the original config.py when creating temp config.

else:
    # --- Use Default Configuration Values ---
    INPUT_EXCEL_FILE = INPUT_EXCEL_FILE_DEFAULT
    OUTPUT_EXCEL_FILE = OUTPUT_EXCEL_FILE_DEFAULT
    TODAY_DATE_STR = TODAY_DATE_STR_DEFAULT
    LEAD_TIME_DAYS = LEAD_TIME_DAYS_DEFAULT
    FAR_FUTURE_DATE_STR = FAR_FUTURE_DATE_STR_DEFAULT
    CAPACITY_TOLERANCE = CAPACITY_TOLERANCE_DEFAULT
    MIN_CAPACITY_REMAIN = MIN_CAPACITY_REMAIN_DEFAULT
    OCD_COL_NAME = OCD_COL_NAME_DEFAULT
    FAR_FUTURE_DATE_DISPLAY_STR = FAR_FUTURE_DATE_DISPLAY_STR_DEFAULT

# --- Date Conversions ---
# These should use the variables (either from exec or defaults)
# Ensure these are defined *after* the potential override by exec() or default assignment.
# The temp config from app.py will write TODAY_DATE_STR, so we just need to convert it.
# It does not write TODAY_DATE directly as a datetime object.

# If INPUT_EXCEL_FILE, etc., were loaded by exec(), they are already in globals().
# If not, they were set in the `else` block above.

TODAY_DATE = pd.to_datetime(TODAY_DATE_STR)
FAR_FUTURE_DATE = pd.to_datetime(FAR_FUTURE_DATE_STR)

# Ensure other essential config variables are set if not by exec
if 'LEAD_TIME_DAYS' not in globals(): LEAD_TIME_DAYS = LEAD_TIME_DAYS_DEFAULT
if 'FAR_FUTURE_DATE_DISPLAY_STR' not in globals(): FAR_FUTURE_DATE_DISPLAY_STR = FAR_FUTURE_DATE_DISPLAY_STR_DEFAULT
if 'CAPACITY_TOLERANCE' not in globals(): CAPACITY_TOLERANCE = CAPACITY_TOLERANCE_DEFAULT
if 'MIN_CAPACITY_REMAIN' not in globals(): MIN_CAPACITY_REMAIN = MIN_CAPACITY_REMAIN_DEFAULT
if 'OCD_COL_NAME' not in globals(): OCD_COL_NAME = OCD_COL_NAME_DEFAULT


# --- Original Configuration (Comment out or remove the old static assignments for these) ---
# INPUT_EXCEL_FILE = 'PO - Request.xlsx' # Now handled above
# OUTPUT_EXCEL_FILE = 'Output_Stock_Management.xlsx' # Now handled above
# TODAY_DATE_STR = date.today().strftime('%Y-%m-%d') # Now handled above
# LEAD_TIME_DAYS = 40 # Now handled above
# FAR_FUTURE_DATE_STR = '2200-12-31' # Now handled above
# CAPACITY_TOLERANCE = 2000 # Now handled above
# MIN_CAPACITY_REMAIN = -2000 # Now handled above
# OCD_COL_NAME = "OCD( Order Creation Day)" # Now handled above

# Convert string dates to datetime objects
# TODAY_DATE = pd.to_datetime(TODAY_DATE_STR) # Now handled above
# FAR_FUTURE_DATE = pd.to_datetime(FAR_FUTURE_DATE_STR) # Now handled above
# FAR_FUTURE_DATE_DISPLAY_STR = 'Insufficient Stock/Capacity' # Now handled above

# --- Helper Functions ---
def excel_date_to_datetime(excel_date):
    """Converts Excel serial date to datetime object, handles existing datetime objects or NaT."""
    if pd.isna(excel_date):
        return pd.NaT
    if isinstance(excel_date, (datetime.datetime, datetime.date)):
        return pd.to_datetime(excel_date)
    try:
        if isinstance(excel_date, (int, float)):
            return pd.to_datetime('1899-12-30') + pd.to_timedelta(excel_date, 'D')
    except ValueError:
        pass # Fallback to direct conversion
    return pd.to_datetime(excel_date, errors='coerce') 